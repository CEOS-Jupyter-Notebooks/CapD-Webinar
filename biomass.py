# -*- coding: utf-8 -*-
"""biomass.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1et0xxWpOsGi86YyKwMG2hBWwPoy8Ogl1

# contains functions that help with accessing the biomass maps from NCEO
"""

'''
The following lines need to be added to the main program:

!pip install rasterio
!pip install rasterstats
!pip install geopandas
'''

# import libraries
import csv 
import geopandas as gpd
import matplotlib.colors as colors
from math import floor, ceil
import matplotlib.pyplot as plt
import numpy as np
from osgeo import gdal, ogr
import os
from os import listdir
from os.path import isfile, isdir, join
import pickle
from pprint import pprint
from pyproj import Proj
from random import seed, random
import rasterio
from rasterio import plot
from rasterio.windows import Window
from rasterio.warp import Resampling
from rasterstats import zonal_stats
import sys
import zipfile

def unzip(zipfilename, target_dir=None):
  '''
  simplified unzipping function

  arguments:
  zipfilename = full path and filename of the file to be unzipped
  target_dir (optional) = target directory to extract all contents of the zipfile to
  '''  
  
  # get current working directory
  cwd = os.getcwd()
  
  # go to target directory where the unzipped files will be put
  if target_dir==None:
    target_dir = cwd
  
  # unzip all contents of the zip file
  with zipfile.ZipFile(zipfilename, 'r') as zip_ref:
    zip_ref.extractall(target_dir)
  
  return()

def get_shp_extent(shapefile):
  '''
  Get the shapefile layer extent, the CRS and the EPSG code

  Args:
    shapefile = path and filename of the shapefile *.shp
  '''
  
  driver = ogr.GetDriverByName("ESRI Shapefile")
  ds = driver.Open(shapefile, 0)

  # get extent
  lyr = ds.GetLayer()
  extent = lyr.GetExtent()

  # get projection information
  SpatialRef = lyr.GetSpatialRef()

  # get EPSG code of the CRS
  EPSG = SpatialRef.GetAttrValue("AUTHORITY", 1)
  
  # close file
  ds = None

  return(extent, SpatialRef, EPSG)

def longlat2window(lon, lat, dataset):
  """
  converts longitude, latitude coordinates into pixel locations 
    using the dataset CRS and transform

  Args:
    lon (tuple): Tuple of min and max lon
    lat (tuple): Tuple of min and max lat
    dataset: Rasterio dataset

  Returns:
    rasterio.windows.Window
  """

  p = Proj(dataset.crs)
  t = dataset.transform
  xmin, ymin = p(lon[0], lat[0])
  xmax, ymax = p(lon[1], lat[1])
  col_min, row_min = ~t * (xmin, ymin)
  col_max, row_max = ~t * (xmax, ymax)
  return Window.from_slices(rows=(floor(row_max), ceil(row_min)),
                            cols=(floor(col_min), ceil(col_max)))

def bytescale(afile, f, factor=16, missing=65535): 
  '''
  Make a quicklook image at reduced resolution for visualisation.
  The function rescales the a raster file to 0-255 and changes it to uint8 data type.
  A new downsampled byte-scale raster file is created.

  Args:
    afile = directory path and filename of an image file
    f = the output file name
    factor (optional) = resampling factor for the quicklook
    missing (optional) = missing values that will be excluded from the byte scaling
  '''

  with rasterio.open(afile) as dataset:
    # resample data to target shape
    data = dataset.read(
      out_shape=(
        dataset.count,
        int(dataset.height / factor),
        int(dataset.width / factor)
      ),
      resampling=Resampling.average
    )

    # scale image transform
    outtransform = dataset.transform * dataset.transform.scale(
        (dataset.width / data.shape[-1]),
        (dataset.height / data.shape[-2])
    )

    # byte scaling
    amin = float(data[np.where(data != missing)].min())
    amax = float(data[np.where(data != missing)].max())
    anewmin = 0.0
    anewmax = 255.0
    ascaled = (data.astype(float) - amin) * ((anewmax - anewmin) / (amax - amin)) + anewmin
    ascaled[np.where(data == missing)] = 0

    print("Creating quicklook byte-scaled image file: ", f)
    '''
    print("Input image height: ", dataset.height)
    print("Input image width: ", dataset.width)
    print("Output image height: ", data.shape[1])
    print("Output image width: ", data.shape[2])
    print("Input and output CRS: ", dataset.crs)
    print("Input image transform: ")
    print(dataset.transform)
    print("Output image transform: ")
    print(outtransform)
    '''
    
    # save the downsampled byte image to a new file
    outfile = rasterio.open(f, 'w', driver='Gtiff', width=data.shape[2], height=data.shape[1],
                            count=1, crs=dataset.crs, transform=outtransform, dtype=np.uint8)
    outfile.write(ascaled.astype(np.uint8)[0,:,:], 1)
    outfile.close()

  dataset.close()

  return()

def plot_map(afile, xlim=None, ylim=None, cmap='Greens', title=None, log=False, legend=True, legendlabel=None, **kwargs): 
  '''
  Plots a raster file of uint8 data type with a single band and adds a legend (optional).

  Args:
    afile = directory path and filename of an image file
    xlim = [xmin, xmax] (optional) is the map extent to be shown in x direction in map coordinates
    ylim = [ymin, ymax] (optional) is the map extent to be shown in y direction in map coordinates
    cmap (optional) = colour map that can be modified by the user
    title (optional) = string for the plot title
    log (optional) = if True, use a logarithmic color map
    legend (optional) = if True, plot a legend
    legendlabel (optional) = string for the colorbar label
    kwargs (optional) = optional other plotting parameters for Matplotlib

  Returns a figure and axes object
  '''

  # create a figure and axes object
  fig, ax = plt.subplots(1, 1, **kwargs)

  # open the temporary file and plot the image
  imgfile = rasterio.open(afile, 'r', count=1)
  px = imgfile.read(1)

  if (xlim==None):
    xlim=[imgfile.bounds.left, imgfile.bounds.right]
    # .bounds returns a BoundingBox(left, bottom, right, top) object

  if (ylim==None):
    ylim=[imgfile.bounds.bottom, imgfile.bounds.top]
  
  # zoom in to an area of interest if defined
  ax.set_xlim(xlim)
  ax.set_ylim(ylim)

  if log == False:
    # plot on the same axis with rasterio.plot.show with a linear color map
    myplot = plot.show(imgfile, ax=ax, cmap=cmap)

    if legend:
      # use imshow so that we have something to map the colorbar to
      myplot_invisible = ax.imshow(px, cmap=cmap)
      # add colorbar using the now hidden image
      cbar = fig.colorbar(myplot_invisible, ax=ax)
      if legendlabel:
        cbar.ax.get_yaxis().labelpad = 15
        cbar.ax.set_ylabel(legendlabel, rotation=270)
      ax.set_axis_off()

  else:
    # avoid negative or zero values on logarithmic axis
    if px.min() > 0:
      pxmin = px.min()
    else:
      pxmin = 0.001
      print("WARNING: Zero or negative values detected. Changing  minimum value for color bar from ", px.min(), " to ", pxmin)

    # plot on the same axis with rasterio.plot.show with a logarithmic color map
    myplot = plot.show(imgfile, ax=ax, cmap=cmap, norm=colors.LogNorm(vmin=pxmin, vmax=px.max()))

    if legend:
      # use imshow so that we have something to map the colorbar to
      myplot_invisible = ax.imshow(px, cmap=cmap, norm=colors.LogNorm(vmin=pxmin, vmax=px.max()))
      # add colorbar using the now hidden image
      cbar = fig.colorbar(myplot_invisible, ax=ax)
      if legendlabel:
        cbar.ax.get_yaxis().labelpad = 15
        cbar.ax.set_ylabel(legendlabel, rotation=270)
      ax.set_axis_off()

  if title is not None:
    ax.set_title(title)

  # close the file
  imgfile.close()

  return(fig, ax)

def sample_raster(afile, n=1000, missing=65535):
  '''
  Draws a random sample of n pixel values from a raster but excludes missing values.
  Sampling is done without replacement.
  Returns a list of pixel values.
  Pixel locations are recorded in the function but are not currently returned.
  
  Args:
    afile = file name of the raster file
    n = number of samples
    missing = No Data value in the raster
  '''

  pxs = [] # list of pixel coordinates in x
  pys = [] # list of pixel coordinates in y
  vals = [] # list of pixel values

  dataset = rasterio.open(afile, 'r')

  seed(1)
  
  while True:
  
    # generate a random pixel coordinate pair
    px = int(random()*dataset.width)
    py = int(random()*dataset.height)

    # create 1x1px window of the pixel
    window = rasterio.windows.Window(px - 1//2, py - 1//2, 1, 1)

    # read rgb values of the single-pixel window but exclude missing values
    clip = dataset.read(window=window)
    if clip[0][0][0] != missing:
      if px not in pxs and py not in pys:
        vals.append(clip[0][0][0])
        pxs.append(px)
        pxs.append(py)

    if len(vals)==n:
      break

  return(vals)

def hist_sample(imagefile, n=1000, missing=65535, title=None, **kwargs):
  '''
  shows a histogram of a pixel sample from a raster image file with a single band

  Args:
    imagefile = path and file name of the raster image
    n (optional) = sample size
    missing (optional) = missing value to be excluded from the histogram plot
    title (optional) = plot title
    kwargs (optional) = optional parameters for Matplotlib
    
  Returns a figure and axes object
  '''

  # unpack the keyword arguments for the figure object
  fig_kwargs = {"figsize" : kwargs.get("figsize", (6,6)),
                "dpi" : kwargs.get("dpi", None),
                "facecolor" : kwargs.get("facecolorfig", "white"),
                "edgecolor" : kwargs.get("edgecolor", "black"),
                "linewidth" : kwargs.get("linewidth", 1),
                "frameon" : kwargs.get("frameon", None),
                "subplotpars" : kwargs.get("subplotpars", None),
                "tight_layout" : kwargs.get("tight_layout", None),
                "constrained_layout" : kwargs.get("constrained_layout", None)
                }

  # create a figure and axes object
  fig, ax = plt.subplots(1, 1, **fig_kwargs)

  # sample the raster
  pixels = sample_raster(imagefile, n, missing)

  # unpack the keyword arguments for the axes.hist object
  hist_kwargs = {"bins" : kwargs.get("bins", 20),
                 "range" : kwargs.get("range", None),
                 "density" : kwargs.get("density", None),
                 "weights" : kwargs.get("weights", None),
                 "cumulative" : kwargs.get("cumulative", False),
                 "bottom" : kwargs.get("bottom", None),
                 "histtype" : kwargs.get("histtype", "bar"),
                 "align" : kwargs.get("align", "mid"),
                 "orientation" : kwargs.get("orientation", "vertical"),
                 "log" : kwargs.get("log", False),
                 "color" : kwargs.get("color", "skyblue"),
                 "label" : kwargs.get("label", None),
                 "stacked" : kwargs.get("stacked", False),
                 "data" : kwargs.get("data", None),
                 "linewidth" : kwargs.get("linewidth", 1),
                 "antialiased" : kwargs.get("antialiased", None),
                 "hatch" : kwargs.get("hatch", None),
                 "fill" : kwargs.get("fill", True),
                 "capstyle" : kwargs.get("capstyle", "round"),
                 "joinstyle" : kwargs.get("joinstyle", "miter"),
                 "agg_filter" : kwargs.get("agg_filter", None),
                 "alpha" : kwargs.get("alpha", None),
                 "clip_box" : kwargs.get("clip_box", None),
                 "clip_on" : kwargs.get("clip_on", None),
                 "clip_path" : kwargs.get("clip_path", None),
                 "gid" : kwargs.get("gid", None),
                 "edgecolor" : kwargs.get("edgecolor", None),
                 "facecolor" : kwargs.get("facecolorhist", None),
                 "in_layout" : kwargs.get("in_layout", False),
                 "linestyle" : kwargs.get("linestyle", "-"),
                 "rasterized" : kwargs.get("rasterized", None),
                 "snap" : kwargs.get("snap", None),
                 "url" : kwargs.get("url", None),
                 "visible" : kwargs.get("visible", True),
                 "zorder" : kwargs.get("zorder", None)
                  }

  # plot the histogram
  ax.hist(pixels, **hist_kwargs)

  # add a title if specified
  if title is not None:
    ax.set_title(title)
  
  return(fig, ax)

def get_zonal_stats(imagefile, shapefile, format, outfile = None, 
                    stats = ["count", "mean", "std"], missing=None, 
                    prefix="_"):
  '''
  Gets zonal stats and saves the statistics to a csv file, as a pickle file or alternatively
    as new columns to a dbf file.
  At least one of the output file names (csvfile, pklfile or dbffile) must be provided.

  Args:
    imagefile = path and file name of the raster image file 
    shapefile = path and file name of the ESRI shape file 
    format = either "csv", "pkl" or "dbf" are supported
    outfile (optional) = path and file name of output file (either a new csv file or a new pickle file if either option is selected)
    stats (optional) = list of strings with statistics to be calculated
    missing (optional) = missing data value to be excluded from the statistics
    prefix (optional) = prefix of the new column names if the option dbf is selected
  '''

  # check a valid format option is given
  if (format != "pkl") and (format != "csv") and (format != "dbf"):
    print("Error in format option. Must be either pkl, csv or dbf")

  # Get zonal statistics for all polygons in the shapefile.
  # The result is a 'list of dictionaries'.
  statsoptions = ""
  for i in stats:
    statsoptions = statsoptions + " " + i
  
  if missing is not None:
    # exclude missing values from calculation by setting a nodata value
    zs = zonal_stats(shapefile, imagefile, nodata=missing, stats=statsoptions)
  else:
    zs = zonal_stats(shapefile, imagefile, stats=statsoptions)

  # get the number of polygons of the shapefile
  n = len(zs)

  if format == "csv":
    # Write the statistics results to a csv file (overwrite if exists)
    f = open(outfile, "w", newline="\n")

    with f: 
      writer = csv.DictWriter(f, fieldnames = stats) 
      writer.writeheader() 
      # iterate over each polygon
      for i in range(n):
        # writing data row-wise into the csv file 
        writer.writerow(zs[i]) 

    # save and close the file
    f.close()

  if format == "dbf":
    # save to dbf
    # open the polygons and attribute table from the shapefile using Geopandas
    gdf = gpd.read_file(shapefile) # returns a GeoDataFrame object

    # add new columns (fields) with the zonal statistics outputs
    for i in stats:
      print("Adding new column: ", prefix + i)
      gdf[prefix + i] = [b[i] for b in zs]

    # save the modified shapefile with the expanded attribute table
    gdf.to_file(outfile)

  if format == "pkl":
    # write the Python object with the polygon statistics to the pickle file
    pickle.dump(zs, open(outfile, 'wb'))

  return()

def hist_dbf(shapefile, attr, ax, bins = 20, missing=None, facecolor='green', title=None):
  '''
  plots a histogram of a chosen column in a dbf file

  Args:
    shapefile = path and file name of the shapefile whose attribute table in dbf format will be read
    attr = string with the attribute column name that will be plotted in the histogram
    ax = axes object on which the histogram will be plotted
    bins (optional) = number of bins for the histogram
    missing (optional) = missing value to be excluded from the histogram plot
    facecolor (optional) = colour of the bars
    title (optional) = string of the plot title

  '''

  # open the polygons and attribute table from the shapefile using Geopandas
  gdf = gpd.read_file(shapefile) # returns a GeoDataFrame object

  # get the attribute values and flatten the array to a list object
  col = gdf[attr].tolist()

  # remove missing values
  if missing is not None:
    colrm = [num for num in col if num != missing]  
  else:
    colrm = col

  # plot histogram
  ax.hist(colrm, bins=bins, facecolor=facecolor)

  # add title
  if title is not None:
    ax.set_title(title)

  return()